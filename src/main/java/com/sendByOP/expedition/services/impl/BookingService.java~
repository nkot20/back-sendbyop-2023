package com.sendByOP.expedition.services.impl;

import com.sendByOP.expedition.exception.ErrorInfo;
import com.sendByOP.expedition.exception.SendByOpException;
import com.sendByOP.expedition.models.dto.*;
import com.sendByOP.expedition.models.entities.*;
import com.sendByOP.expedition.models.enums.BookingStatus;
import com.sendByOP.expedition.repositories.*;
import com.sendByOP.expedition.services.FileStorageService;
import com.sendByOP.expedition.services.iServices.IBookingService;
import com.sendByOP.expedition.services.iServices.IPlatformSettingsService;
import com.sendByOP.expedition.services.iServices.IReceiverService;
import jakarta.transaction.Transactional;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.multipart.MultipartFile;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Service de gestion des réservations de transport de colis
 */
@Slf4j
@Service
@Transactional
@RequiredArgsConstructor
@Validated
public class BookingService implements IBookingService {

    private final BookingRepository bookingRepository;
    private final FlightRepository flightRepository;
    private final CustomerRepository customerRepository;
    private final IReceiverService receiverService;
    private final IPlatformSettingsService platformSettingsService;
    private final FileStorageService fileStorageService;

    @Override
    public BookingResponseDto createBooking(
            @Valid CreateBookingRequest request,
            MultipartFile[] parcelPhotos,
            String customerId) throws SendByOpException {
        
        log.info("Creating booking for customer {} on flight {} with {} photos", 
                customerId, request.getFlightId(), parcelPhotos != null ? parcelPhotos.length : 0);
        
        // 1. Validation photos requises (1 à 5)
        if (parcelPhotos == null || parcelPhotos.length == 0) {
            log.error("At least one parcel photo is required");
            throw new SendByOpException(ErrorInfo.INVALID_DATA,
                    "Au moins une photo du colis est requise");
        }
        
        if (parcelPhotos.length > 5) {
            log.error("Too many photos: {}", parcelPhotos.length);
            throw new SendByOpException(ErrorInfo.INVALID_DATA,
                    "Maximum 5 photos autorisées (reçu: " + parcelPhotos.length + ")");
        }
        
        // 2. Vérifier que le client existe
        Customer customer = customerRepository.findByEmail(customerId)
                .orElseThrow(() -> {
                    log.error("Customer not found: {}", customerId);
                    return new SendByOpException(ErrorInfo.RESOURCE_NOT_FOUND,
                            "Client non trouvé");
                });
        
        // 3. Vérifier que le vol existe
        Flight flight = flightRepository.findById(request.getFlightId())
                .orElseThrow(() -> {
                    log.error("Flight not found: {}", request.getFlightId());
                    return new SendByOpException(ErrorInfo.RESOURCE_NOT_FOUND,
                            "Vol non trouvé");
                });
        
        // 4. GetOrCreate destinataire
        ReceiverDto receiverDto = ReceiverDto.builder()
                .firstName(request.getReceiverFirstName())
                .lastName(request.getReceiverLastName())
                .email(request.getReceiverEmail())
                .phoneNumber(request.getReceiverPhoneNumber())
                .address(request.getReceiverAddress())
                .city(request.getReceiverCity())
                .country(request.getReceiverCountry())
                .build();
        
        ReceiverDto receiver = receiverService.getOrCreateReceiver(receiverDto);
        log.debug("Receiver: {}", receiver.getId());
        
        // 5. Upload photos du colis (approche fonctionnelle)
        List<String> photoUrls = Arrays.stream(parcelPhotos)
                .filter(photo -> !photo.isEmpty())  // Filtrer les photos vides
                .map(photo -> {
                    try {
                        String photoUrl = fileStorageService.storeProfilePicture(photo, customerId);
                        log.debug("Parcel photo uploaded: {}", photoUrl);
                        return photoUrl;
                    } catch (Exception e) {
                        log.error("Failed to upload parcel photo", e);
                        throw new RuntimeException("Erreur lors de l'upload d'une photo du colis: " + e.getMessage(), e);
                    }
                })
                .collect(Collectors.toList());
        
        if (photoUrls.isEmpty()) {
            throw new SendByOpException(ErrorInfo.INVALID_DATA,
                    "Aucune photo valide n'a pu être uploadée");
        }
        
        log.info("{} photo(s) uploaded successfully", photoUrls.size());
        
        // 6. Calculer le prix
        BigDecimal totalPrice = calculatePrice(request);
        log.debug("Calculated price: {}", totalPrice);
        
        // 7. Créer la réservation
        Booking booking = new Booking();
        booking.setCustomer(customer);
        booking.setFlight(flight);
        
        // Récupérer l'entité Receiver depuis la BD
        Receiver receiverEntity = receiverService
                .getReceiverByEmail(receiver.getEmail()) != null ?
                customerRepository.findById(receiver.getId())
                        .map(c -> {
                            // Workaround: on doit récupérer le Receiver entity
                            Receiver r = new Receiver();
                            r.setId(receiver.getId());
                            r.setFirstName(receiver.getFirstName());
                            r.setLastName(receiver.getLastName());
                            r.setEmail(receiver.getEmail());
                            r.setPhoneNumber(receiver.getPhoneNumber());
                            r.setAddress(receiver.getAddress());
                            r.setCity(receiver.getCity());
                            r.setCountry(receiver.getCountry());
                            r.setStatus(receiver.getStatus());
                            return r;
                        }).orElse(null) : null;
        
        booking.setReceiver(receiverEntity);
        booking.setStatus(BookingStatus.PENDING_CONFIRMATION);
        booking.setBookingDate(new Date());
        booking.setTotalPrice(totalPrice);
        
        // Pour compatibilité: définir la première photo comme URL principale
        booking.setParcelPhotoUrl(photoUrls.get(0));
        
        // 7bis. Créer les entités ParcelPhoto (approche fonctionnelle)
        List<ParcelPhoto> parcelPhotoEntities = IntStream.range(0, photoUrls.size())
                .mapToObj(index -> ParcelPhoto.builder()
                        .photoUrl(photoUrls.get(index))
                        .displayOrder(index)
                        .isPrimary(index == 0)  // La première est la principale
                        .booking(booking)
                        .build())
                .collect(Collectors.toList());
        
        // Associer les photos à la réservation (cascade sauvera automatiquement)
        booking.setParcelPhotos(parcelPhotoEntities);
        
        // Sauvegarder
        Booking saved = bookingRepository.save(booking);
        log.info("Booking created successfully: {}", saved.getId());
        
        // 8. Construire la réponse avec les photos
        List<ParcelPhotoDto> photoDtos = saved.getParcelPhotos().stream()
                .map(photo -> ParcelPhotoDto.builder()
                        .id(photo.getId())
                        .photoUrl(photo.getPhotoUrl())
                        .description(photo.getDescription())
                        .displayOrder(photo.getDisplayOrder())
                        .isPrimary(photo.getIsPrimary())
                        .build())
                .collect(Collectors.toList());
        
        return BookingResponseDto.builder()
                .id(saved.getId())
                .status(saved.getStatus())
                .bookingDate(saved.getBookingDate())
                .confirmedAt(saved.getConfirmedAt())
                .paymentDeadline(saved.getPaymentDeadline())
                .totalPrice(saved.getTotalPrice())
                .flightId(flight.getFlightId())
                .customerId(customer.getId())
                .receiverId(receiver.getId())
                .parcelPhotos(photoDtos)  // Nouvelle liste de photos
                .parcelPhotoUrl(saved.getParcelPhotoUrl())  // Compatibilité
                .receiverFullName(receiver.getFirstName() + " " + receiver.getLastName())
                .receiverEmail(receiver.getEmail())
                .receiverPhoneNumber(receiver.getPhoneNumber())
                .parcelWeight(request.getParcelWeight())
                .parcelDescription(request.getParcelDescription())
                .build();
    }
    
    /**
     * Calcule le prix de la réservation
     * Utilise le prix proposé s'il est valide, sinon calcule selon les settings
     */
    private BigDecimal calculatePrice(CreateBookingRequest request) throws SendByOpException {
        PlatformSettingsDto settings = platformSettingsService.getSettings();
        
        BigDecimal weight = request.getParcelWeight();
        BigDecimal minPrice = settings.getMinPricePerKg().multiply(weight);
        BigDecimal maxPrice = settings.getMaxPricePerKg().multiply(weight);
        
        // Si un prix est proposé
        if (request.getProposedPrice() != null) {
            BigDecimal proposedPrice = request.getProposedPrice();
            
            // Vérifier qu'il est dans les limites
            if (proposedPrice.compareTo(minPrice) < 0) {
                log.error("Proposed price too low: {} < {}", proposedPrice, minPrice);
                throw new SendByOpException(ErrorInfo.INVALID_DATA,
                        "Le prix proposé est inférieur au minimum autorisé: " + minPrice + "€");
            }
            
            if (proposedPrice.compareTo(maxPrice) > 0) {
                log.error("Proposed price too high: {} > {}", proposedPrice, maxPrice);
                throw new SendByOpException(ErrorInfo.INVALID_DATA,
                        "Le prix proposé est supérieur au maximum autorisé: " + maxPrice + "€");
            }
            
            return proposedPrice;
        }
        
        // Sinon, calculer un prix moyen
        return minPrice.add(maxPrice).divide(BigDecimal.valueOf(2));
    }
    
    @Override
    public BookingResponseDto confirmBooking(Integer bookingId, Integer travelerId) throws SendByOpException {
        log.info("Confirming booking {} by traveler {}", bookingId, travelerId);
        
        // 1. Vérifier que la réservation existe
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> {
                    log.error("Booking not found: {}", bookingId);
                    return new SendByOpException(ErrorInfo.RESOURCE_NOT_FOUND,
                            "Réservation non trouvée");
                });
        
        // 2. Vérifier que le voyageur est propriétaire du vol
        Integer flightOwnerId = booking.getFlight().getCustomer().getId();
        if (!flightOwnerId.equals(travelerId)) {
            log.error("Traveler {} is not owner of flight {}", travelerId, booking.getFlight().getFlightId());
            throw new SendByOpException(ErrorInfo.UNAUTHORIZED,
                    "Vous n'êtes pas autorisé à confirmer cette réservation");
        }
        
        // 3. Vérifier que le statut est PENDING_CONFIRMATION
        if (booking.getStatus() != BookingStatus.PENDING_CONFIRMATION) {
            log.error("Invalid status for confirmation: {}", booking.getStatus());
            throw new SendByOpException(ErrorInfo.INVALID_STATUS,
                    "La réservation ne peut être confirmée dans son état actuel");
        }
        
        // 4. Mettre à jour le statut vers CONFIRMED_UNPAID
        booking.setStatus(BookingStatus.CONFIRMED_UNPAID);
        
        // 5. Définir la deadline de paiement (selon PlatformSettings)
        PlatformSettingsDto settings = platformSettingsService.getSettings();
        LocalDateTime paymentDeadline = LocalDateTime.now()
                .plusHours(settings.getPaymentTimeoutHours());
        booking.setPaymentDeadline(paymentDeadline);
        
        // 6. Enregistrer la date de confirmation
        booking.setConfirmedAt(LocalDateTime.now());
        
        // Sauvegarder
        Booking saved = bookingRepository.save(booking);
        log.info("Booking {} confirmed successfully", bookingId);
        
        // Retourner la réponse
        return buildBookingResponse(saved);
    }
    
    @Override
    public BookingResponseDto rejectBooking(Integer bookingId, Integer travelerId, String reason) throws SendByOpException {
        log.info("Rejecting booking {} by traveler {}", bookingId, travelerId);
        
        // 1. Vérifier que la réservation existe
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> {
                    log.error("Booking not found: {}", bookingId);
                    return new SendByOpException(ErrorInfo.RESOURCE_NOT_FOUND,
                            "Réservation non trouvée");
                });
        
        // 2. Vérifier que le voyageur est propriétaire du vol
        Integer flightOwnerId = booking.getFlight().getCustomer().getId();
        if (!flightOwnerId.equals(travelerId)) {
            log.error("Traveler {} is not owner of flight {}", travelerId, booking.getFlight().getFlightId());
            throw new SendByOpException(ErrorInfo.UNAUTHORIZED,
                    "Vous n'êtes pas autorisé à rejeter cette réservation");
        }
        
        // 3. Vérifier que le statut est PENDING_CONFIRMATION
        if (booking.getStatus() != BookingStatus.PENDING_CONFIRMATION) {
            log.error("Invalid status for rejection: {}", booking.getStatus());
            throw new SendByOpException(ErrorInfo.INVALID_STATUS,
                    "La réservation ne peut être rejetée dans son état actuel");
        }
        
        // 4. Mettre à jour le statut vers CANCELLED_BY_TRAVELER
        booking.setStatus(BookingStatus.CANCELLED_BY_TRAVELER);
        
        // 5. Enregistrer la raison du rejet
        if (reason != null && !reason.trim().isEmpty()) {
            booking.setCancellationReason(reason);
        }
        
        // Sauvegarder
        Booking saved = bookingRepository.save(booking);
        log.info("Booking {} rejected successfully", bookingId);
        
        // Retourner la réponse
        return buildBookingResponse(saved);
    }
    
    @Override
    public BookingResponseDto processPayment(Integer bookingId, PaymentRequest paymentRequest, Integer customerId) throws SendByOpException {
        log.info("Processing payment for booking {} by customer {}", bookingId, customerId);
        
        // 1. Vérifier que la réservation existe
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> {
                    log.error("Booking not found: {}", bookingId);
                    return new SendByOpException(ErrorInfo.RESOURCE_NOT_FOUND,
                            "Réservation non trouvée");
                });
        
        // 2. Vérifier que le client est propriétaire de la réservation
        if (!booking.getCustomer().getId().equals(customerId)) {
            log.error("Customer {} is not owner of booking {}", customerId, bookingId);
            throw new SendByOpException(ErrorInfo.UNAUTHORIZED,
                    "Vous n'êtes pas autorisé à payer cette réservation");
        }
        
        // 3. Vérifier que le statut est CONFIRMED_UNPAID
        if (booking.getStatus() != BookingStatus.CONFIRMED_UNPAID) {
            log.error("Invalid status for payment: {}", booking.getStatus());
            throw new SendByOpException(ErrorInfo.INVALID_STATUS,
                    "La réservation ne peut être payée dans son état actuel");
        }
        
        // 4. Vérifier que la deadline de paiement n'est pas dépassée
        if (booking.getPaymentDeadline() != null && 
                LocalDateTime.now().isAfter(booking.getPaymentDeadline())) {
            log.error("Payment deadline exceeded for booking {}", bookingId);
            throw new SendByOpException(ErrorInfo.PAYMENT_FAILED,
                    "Le délai de paiement est dépassé");
        }
        
        // 5. Valider le montant (doit correspondre au totalPrice)
        if (paymentRequest.getAmount().compareTo(booking.getTotalPrice()) != 0) {
            log.error("Payment amount mismatch: {} vs {}", 
                    paymentRequest.getAmount(), booking.getTotalPrice());
            throw new SendByOpException(ErrorInfo.INVALID_DATA,
                    "Le montant du paiement ne correspond pas au prix de la réservation");
        }
        
        // 6. [Future] Traiter le paiement via gateway (Stripe/PayPal)
        // Pour l'instant, on considère le paiement comme réussi
        log.debug("Payment method: {}", paymentRequest.getPaymentMethod());
        
        // 7. Mettre à jour le statut vers CONFIRMED_PAID
        booking.setStatus(BookingStatus.CONFIRMED_PAID);
        
        // 8. Enregistrer les détails du paiement
        // Note: Ces informations devraient normalement être dans une entité Payment séparée
        log.debug("Payment processed successfully for booking {}", bookingId);
        
        // Sauvegarder
        Booking saved = bookingRepository.save(booking);
        log.info("Payment processed successfully for booking {}", bookingId);
        
        // Retourner la réponse
        return buildBookingResponse(saved);
    }
    
    @Override
    public BookingResponseDto cancelByClient(Integer bookingId, Integer customerId, String reason) throws SendByOpException {
        log.info("Cancelling booking {} by client {}", bookingId, customerId);
        
        // 1. Vérifier que la réservation existe
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> {
                    log.error("Booking not found: {}", bookingId);
                    return new SendByOpException(ErrorInfo.RESOURCE_NOT_FOUND,
                            "Réservation non trouvée");
                });
        
        // 2. Vérifier que le client est propriétaire de la réservation
        if (!booking.getCustomer().getId().equals(customerId)) {
            log.error("Customer {} is not owner of booking {}", customerId, bookingId);
            throw new SendByOpException(ErrorInfo.UNAUTHORIZED,
                    "Vous n'êtes pas autorisé à annuler cette réservation");
        }
        
        // 3. Vérifier que le statut permet l'annulation
        if (booking.getStatus() == BookingStatus.DELIVERED || 
            booking.getStatus() == BookingStatus.PICKED_UP ||
            booking.getStatus() == BookingStatus.CANCELLED_BY_CLIENT ||
            booking.getStatus() == BookingStatus.CANCELLED_BY_TRAVELER ||
            booking.getStatus() == BookingStatus.CANCELLED_PAYMENT_TIMEOUT) {
            log.error("Cannot cancel booking in status: {}", booking.getStatus());
            throw new SendByOpException(ErrorInfo.INVALID_STATUS,
                    "La réservation ne peut pas être annulée dans son état actuel");
        }
        
        // 4. Mettre à jour le statut vers CANCELLED_BY_CLIENT
        booking.setStatus(BookingStatus.CANCELLED_BY_CLIENT);
        
        // 5. Enregistrer la raison de l'annulation
        if (reason != null && !reason.trim().isEmpty()) {
            booking.setCancellationReason(reason);
        }
        
        // Sauvegarder
        Booking saved = bookingRepository.save(booking);
        log.info("Booking {} cancelled successfully by client", bookingId);
        
        // Retourner la réponse
        return buildBookingResponse(saved);
    }
    
    @Override
    public int autoCancelUnpaidBookings() {
        log.info("Running auto-cancellation of unpaid bookings");
        
        LocalDateTime now = LocalDateTime.now();
        int cancelledCount = 0;
        
        try {
            // Utilise la requête optimisée du repository
            List<Booking> expiredBookings = bookingRepository.findUnpaidWithExpiredDeadline(
                    BookingStatus.CONFIRMED_UNPAID,
                    now
            );
            
            log.debug("Found {} bookings with expired deadline", expiredBookings.size());
            
            for (Booking booking : expiredBookings) {
                booking.setStatus(BookingStatus.CANCELLED_PAYMENT_TIMEOUT);
                bookingRepository.save(booking);
                cancelledCount++;
                log.debug("Auto-cancelled booking {} (deadline was {})", 
                        booking.getId(), booking.getPaymentDeadline());
            }
            
            if (cancelledCount > 0) {
                log.warn("Auto-cancelled {} unpaid booking(s)", cancelledCount);
            } else {
                log.info("No unpaid bookings to cancel");
            }
        } catch (Exception e) {
            log.error("Error during auto-cancellation", e);
        }
        
        return cancelledCount;
    }
    
    @Override
    public BookingResponseDto markAsDelivered(Integer bookingId, Integer travelerId) throws SendByOpException {
        log.info("Marking booking {} as delivered by traveler {}", bookingId, travelerId);
        
        // 1. Vérifier que la réservation existe
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> {
                    log.error("Booking not found: {}", bookingId);
                    return new SendByOpException(ErrorInfo.RESOURCE_NOT_FOUND,
                            "Réservation non trouvée");
                });
        
        // 2. Vérifier que le voyageur est propriétaire du vol
        Integer flightOwnerId = booking.getFlight().getCustomer().getId();
        if (!flightOwnerId.equals(travelerId)) {
            log.error("Traveler {} is not owner of flight {}", travelerId, booking.getFlight().getFlightId());
            throw new SendByOpException(ErrorInfo.UNAUTHORIZED,
                    "Vous n'êtes pas autorisé à marquer cette réservation comme livrée");
        }
        
        // 3. Vérifier que le statut est CONFIRMED_PAID
        if (booking.getStatus() != BookingStatus.CONFIRMED_PAID) {
            log.error("Invalid status for delivery: {}", booking.getStatus());
            throw new SendByOpException(ErrorInfo.INVALID_STATUS,
                    "La réservation doit être payée pour être marquée comme livrée");
        }
        
        // 4. Mettre à jour le statut vers DELIVERED
        booking.setStatus(BookingStatus.DELIVERED);
        
        // 5. Enregistrer la date de livraison
        booking.setDeliveredAt(LocalDateTime.now());
        
        // Sauvegarder
        Booking saved = bookingRepository.save(booking);
        log.info("Booking {} marked as delivered", bookingId);
        
        // Retourner la réponse
        return buildBookingResponse(saved);
    }
    
    @Override
    public BookingResponseDto markAsPickedUp(Integer bookingId, Integer customerId) throws SendByOpException {
        log.info("Marking booking {} as picked up by customer {}", bookingId, customerId);
        
        // 1. Vérifier que la réservation existe
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> {
                    log.error("Booking not found: {}", bookingId);
                    return new SendByOpException(ErrorInfo.RESOURCE_NOT_FOUND,
                            "Réservation non trouvée");
                });
        
        // 2. Vérifier que le client est propriétaire de la réservation
        if (!booking.getCustomer().getId().equals(customerId)) {
            log.error("Customer {} is not owner of booking {}", customerId, bookingId);
            throw new SendByOpException(ErrorInfo.UNAUTHORIZED,
                    "Vous n'êtes pas autorisé à marquer cette réservation comme récupérée");
        }
        
        // 3. Vérifier que le statut est DELIVERED
        if (booking.getStatus() != BookingStatus.DELIVERED) {
            log.error("Invalid status for pickup: {}", booking.getStatus());
            throw new SendByOpException(ErrorInfo.INVALID_STATUS,
                    "La réservation doit être livrée pour être marquée comme récupérée");
        }
        
        // 4. Mettre à jour le statut vers PICKED_UP
        booking.setStatus(BookingStatus.PICKED_UP);
        
        // 5. Enregistrer la date de récupération
        booking.setPickedUpAt(LocalDateTime.now());
        
        // Sauvegarder
        Booking saved = bookingRepository.save(booking);
        log.info("Booking {} marked as picked up", bookingId);
        
        // Retourner la réponse
        return buildBookingResponse(saved);
    }
    
    /**
     * Construit un BookingResponseDto à partir d'une entité Booking
     */
    private BookingResponseDto buildBookingResponse(Booking booking) {
        Receiver receiver = booking.getReceiver();
        
        // Calculer poids total depuis les parcels
        Double totalWeight = booking.getParcels() != null ? 
                booking.getParcels().stream()
                        .mapToDouble(p -> p.getWeightKg() != null ? p.getWeightKg() : 0.0)
                        .sum() : 0.0;
        
        return BookingResponseDto.builder()
                .id(booking.getId())
                .status(booking.getStatus())
                .bookingDate(booking.getBookingDate())
                .confirmedAt(booking.getConfirmedAt())
                .paymentDeadline(booking.getPaymentDeadline())
                .totalPrice(booking.getTotalPrice())
                .flightId(booking.getFlight().getFlightId())
                .customerId(booking.getCustomer().getId())
                .receiverId(receiver.getId())
                .parcelPhotoUrl(booking.getParcelPhotoUrl())
                .receiverFullName(receiver.getFirstName() + " " + receiver.getLastName())
                .receiverEmail(receiver.getEmail())
                .receiverPhoneNumber(receiver.getPhoneNumber())
                .parcelWeight(BigDecimal.valueOf(totalWeight))
                .parcelDescription(booking.getParcels() != null && !booking.getParcels().isEmpty() ?
                        booking.getParcels().get(0).getDescription() : null)
                .build();
    }
}
