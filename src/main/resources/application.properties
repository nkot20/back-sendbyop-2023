spring.application.name=Sendbyop
server.port=9002
spring.profiles.active=${ACTIVE_PROFILE}
server.servlet.context-path=/api/v1

app.jwt.secret=${JWT_SECRET}
app.jwt.expiration=${JWT_EXPIRATION}
app.jwt.refreshExpiration=${JWT_REFRESH_EXPIRATION}

springdoc.api-docs.version=openapi_3_0
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operations-sorter=method
springdoc.swagger-ui.tags-sorter=alpha
springdoc.swagger-ui.doc-expansion=none
springdoc.api-docs.path=/v3/api-docs
springdoc.api-docs.enabled=true
springdoc.api-docs.resolve-schema-properties=true
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true
springdoc.swagger-ui.config-url=${server.servlet.context-path}/v3/api-docs/swagger-config
springdoc.swagger-ui.url=${server.servlet.context-path}/v3/api-docs

springdoc.packages-to-scan=com.sendByOP.expedition
springdoc.paths-to-match=/**

# ============================================
# CONFIGURATION OPTIMISÉE PERFORMANCE
# SendByOp Backend - Optimisations Scalabilité
# ============================================

# ==========================================
# 1. HIKARI CONNECTION POOL (CRITIQUE)
# ==========================================
# Pool de connexions optimisé pour 500-1000 utilisateurs simultanés
# Ajustez selon votre serveur BD et charge réelle

spring.datasource.hikari.maximum-pool-size=50
spring.datasource.hikari.minimum-idle=10
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.leak-detection-threshold=60000

# ==========================================
# 2. TOMCAT EMBEDDED SERVER
# ==========================================
# Configuration threads pour haute concurrence

server.tomcat.threads.max=400
server.tomcat.threads.min-spare=50
server.tomcat.max-connections=10000
server.tomcat.accept-count=200
server.tomcat.connection-timeout=20000

# Compression des réponses (économise bande passante)
server.compression.enabled=true
server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain,application/javascript,text/css

# ==========================================
# 3. JPA / HIBERNATE OPTIMIZATIONS
# ==========================================
# Batch processing pour réduire les roundtrips BD
spring.jpa.properties.hibernate.jdbc.batch_size=25
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true

# Second level cache (si activé)
spring.jpa.properties.hibernate.cache.use_second_level_cache=false
spring.jpa.properties.hibernate.cache.use_query_cache=false

# Fetch size optimisé
spring.jpa.properties.hibernate.jdbc.fetch_size=50

# Statistiques (activer pour monitoring)
spring.jpa.properties.hibernate.generate_statistics=false

# ==========================================
# 4. REDIS CACHE (DÉJÀ CONFIGURÉ)
# ==========================================
# Configuration existante - À améliorer avec @Cacheable

# Redis temporairement désactivé - Erreur de connexion lors de la vérification email
# Décommenter quand Redis sera disponible
#spring.redis.host=${REDIS_HOST:localhost}
#spring.redis.port=${REDIS_PORT:6379}
#spring.redis.password=${REDIS_PASSWORD:}
#spring.redis.timeout=2000ms
#spring.redis.lettuce.pool.max-active=50
#spring.redis.lettuce.pool.max-idle=20
#spring.redis.lettuce.pool.min-idle=5
spring.cache.type=simple
#spring.cache.type=redis
#spring.cache.redis.time-to-live=600000

# ==========================================
# 5. JACKSON / JSON OPTIMIZATION
# ==========================================
# Améliorer sérialisation JSON

spring.jackson.default-property-inclusion=non_null
spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.deserialization.fail-on-unknown-properties=false

# ==========================================
# 6. LOGGING OPTIMIZATION
# ==========================================
# Logs optimisés pour production

# SQL logs (désactiver en prod pour performance)
spring.jpa.show-sql=false

# Niveaux de logs
logging.level.root=INFO
logging.level.com.sendByOP.expedition=INFO
logging.level.org.springframework.web=WARN
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=WARN

# Pattern optimisé (sans couleurs en prod)
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# ==========================================
# 7. ACTUATOR / MONITORING
# ==========================================
# Endpoints pour monitoring performance

management.endpoints.web.exposure.include=health,metrics,prometheus,info
management.endpoint.health.show-details=when-authorized
management.metrics.enable.jvm=true
management.metrics.enable.tomcat=true
management.metrics.enable.hikaricp=true

# ==========================================
# 8. SECURITY OPTIMIZATIONS
# ==========================================
# JWT déjà configuré (stateless - scalable)

# Rate limiting (à implémenter avec Bucket4j)
# app.rate-limit.requests-per-minute=60

# ==========================================
# NOTES D'UTILISATION
# ==========================================
# 1. Inclure ce fichier dans application.properties:
#    spring.profiles.include=performance
#
# 2. Ou activer via profile:
#    spring.profiles.active=dev,performance
#
# 3. Ajuster les valeurs selon:
#    - RAM serveur (pool-size proportionnel à RAM)
#    - CPU cores (threads max = cores * 2 à 4)
#    - Charge attendue
#
# 4. Monitorer avec Actuator:
#    GET /actuator/metrics/hikaricp.connections.active
#    GET /actuator/metrics/tomcat.threads.busy
#
# ==========================================
# CAPACITÉ ESTIMÉE AVEC CES CONFIGS
# ==========================================
# Utilisateurs simultanés: 500-1,000
# Requêtes/seconde: 300-500
# Temps réponse moyen: 100-200ms
# ==========================================


